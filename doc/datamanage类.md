数据管理层（Data Management Layer）【承上启下，数据的管家】
✅ 对应代码文件

    抽象定义：datamanager_interface.cpp
    具体实现：datamanager_memory.cpp

✅ 核心定位
数据管理层是领域层的「数据管家」，只关心「领域层的实体数据如何存储、如何读取、如何持久化」，不关心「业务逻辑是什么、业务怎么用这些数据」，也不关心「数据要展示给谁」。

    核心使命：为上层提供「干净、统一的领域数据操作接口」，屏蔽数据存储的底层细节。

✅ 分层拆分（数据管理层内部又分「抽象接口」+「具体实现」，你的代码完美做到）
✔️ 2.1 数据管理抽象接口：datamanager_interface.cpp

    核心职责：定义「对领域实体数据能做哪些操作」的标准规范，是数据操作的「契约」，只声明方法，不写任何实现。
    核心内容：纯虚类DataManager中定义了所有数据操作方法，全是针对领域层的实体（SharedStudent/SharedCourse等）的增、查、查全部，以及数据持久化saveData()。
        增：addStudent()/addCourse()/addTeacher()/addSecretary() → 往存储容器中添加领域实体；
        查：getXXXById() → 根据 ID 精准查询领域实体；
        查全部：getAllXXX() → 查询某类实体的全部数据；
        持久化：saveData() → 将内存中的领域实体数据保存到外部介质。
    设计价值：屏蔽存储细节，接口中只写「要做什么」，不写「怎么做」，比如只写saveData()，不写是存文件还是存数据库。

✔️ 2.2 数据管理具体实现：datamanager_memory.cpp

    核心职责：遵循接口规范，实现具体的数据存储逻辑，是接口的「落地代码」，回答「数据具体怎么存、怎么读」。
    核心内容：DataManagerMemory继承DataManager，实现所有纯虚函数，你的代码中是「内存 + 本地 JSON 文件」的存储方式：
        内存存储：用StudentList/CourseList等容器，将领域实体对象保存在内存中，增、查操作都是对内存容器的操作；
        持久化存储：saveData()方法将内存中的领域实体数据，拼接成 JSON 格式写入data.json文件，实现「数据落地」，重启系统后数据不丢失；
        数据校验：添加实体时先查 ID 是否存在，避免重复存储，保证数据唯一性。

✅ 数据管理层核心特点 & 设计亮点

    ✔️ 只依赖领域层：数据管理层的所有操作对象都是领域层的实体，只导入:entity模块，不依赖任何上层，符合「下层不依赖上层」的设计原则；
    ✔️ 接口与实现分离：最核心的设计精髓，接口定规范，实现做具体，后续如果想把「内存 + JSON」换成「PostgreSQL 数据库」，只需要新增一个DataManagerPostgres类实现DataManager接口即可，领域层、应用层、表现层的代码一行都不用改；
    ✔️ 职责单一：这一层只做「数据的增删查存」，没有任何业务逻辑，比如不会判断「学生能不能选课」，只会执行「把学生数据存起来」这个动作。

