written by WangQingming 2025-01-19

# Registrar选课系统核心模块开发心得
Registrar模块作为选课系统的核心业务载体，承接了用户交互、业务逻辑编排、数据层调用的核心职责。开发过程中围绕“模块化、可扩展、高鲁棒”的目标，结合C++20模块特性与面向对象设计思想落地功能，现将核心开发心得总结如下：

## 一、模块化架构：以C++20模块解耦核心逻辑
Registrar模块并非单一文件，而是以`registrar`主模块为核心，整合`registrar:entity`（实体定义）、`registrar:datamanager_interface`（数据层接口）、`registrar:datamanager_memory`（内存版数据实现）等子模块的分层架构，这一设计彻底摆脱了传统C++头文件包含带来的循环依赖、编译冗余问题：
1. **职责边界清晰**：`registrar`主模块仅聚焦“业务流程编排”——如学生/教师/秘书的菜单交互、选课/录成绩/创建课程等核心业务逻辑，不涉及实体类定义和数据层具体实现；实体类统一封装在`entity`子模块，数据操作规范抽象在`datamanager_interface`，内存版实现放在`datamanager_memory`，每个模块仅通过`export`暴露必要接口，内部逻辑完全封装。
2. **模块依赖可控**：主模块通过`import :entity;` `import :datamanager_interface;`引入依赖，且仅依赖“接口”而非“具体实现”（如依赖`DataManager`抽象类而非`DataManagerMemory`），既保证了编译效率，也为后续扩展打下基础。

## 二、接口驱动设计：让核心逻辑与数据层解耦
Registrar模块最核心的设计思路是“面向接口编程”，这一点通过对接`DataManager`接口类充分体现：
1. **依赖抽象而非具体**：主模块中仅声明`std::shared_ptr<DataManager>`类型的`m_dataManager`成员，初始化时通过条件编译（`USE_POSTGRES`宏）选择内存版（`DataManagerMemory`）或未来的Postgres版实现，核心业务逻辑（如`enrollCourse`选课、`inputStudentGrades`录成绩）仅调用`DataManager`的`addCourse`/`getStudentById`等接口，完全不关心数据是存在内存还是数据库。这种设计让数据层的替换不影响任何业务逻辑，完美契合“开闭原则”。
2. **接口设计贴合业务**：`DataManager`接口的方法（如`addStudent`/`getCourseById`/`saveData`）完全对齐Registrar模块的业务需求，没有冗余接口，也没有功能缺失，既保证了调用方的便捷性，也让实现方的开发范围清晰可控。

## 三、面向对象：让业务逻辑贴合现实场景
Registrar模块的核心是将“选课系统”的现实场景映射为代码逻辑，开发中重点落地了面向对象的核心思想：
1. **角色职责具象化**：按“学生/教师/教学秘书”的业务角色拆分菜单（`studentMenu`/`teacherMenu`/`secretaryMenu`），每个角色仅展示权限内的功能——学生只能查课/选课/查成绩，教师只能看授课课程/录成绩，秘书只能创建课程/分配教师，既贴合现实业务规则，也避免了越权操作。
2. **实体关联的一致性保障**：调用`entity`模块中实体类的关联方法（如`Course::addStudent`会触发`Student::enrollIn`），在业务逻辑层无需额外处理“学生选课程”和“课程加学生”的双向关联，仅需调用`course->addStudent(stu)`即可保证数据一致性，减少了业务层的代码冗余和出错概率。
3. **智能指针的安全运用**：全程复用`entity`模块定义的`SharedStudent`/`SharedCourse`等智能指针类型，无需手动管理内存，且通过`enable_shared_from_this`解决了“实体成员函数中传递自身指针”的场景（如教师录成绩时传递课程指针），彻底规避了裸指针导致的内存泄漏或野指针问题。

## 四、鲁棒性设计：从交互到数据的全链路防护
Registrar模块作为用户直接接触的核心层，鲁棒性是开发的重点，主要通过“分层校验+异常处理”保障系统稳定：
1. **输入层：防无效交互**：封装`readInt`工具函数，专门处理用户非数字输入的场景——清空cin缓存、循环提示重新输入，避免因用户误输入导致程序崩溃，这是命令行交互场景下最基础也最关键的防护。
2. **业务层：防无效操作**：核心操作前增加前置校验，比如教师录成绩时先筛选出“自身授课的课程”、再校验“学生是否选了该课程”；秘书创建课程时先检查“课程ID是否已存在”，避免无效数据录入和越权操作。
3. **异常层：友好容错**：捕获实体层抛出的异常（如课程学分超出1-10范围的`invalid_argument`），并转化为用户可理解的提示（如“课程创建失败：学分必须在1-10之间”），而非直接抛出底层异常，提升了用户体验。

## 五、可扩展性：为未来迭代预留空间
开发时并非只满足“当前能用”，而是为后续迭代预留了扩展点：
1. **功能扩展**：菜单设计采用“数字选择+switch-case”的结构，新增功能（如学生退课、教师查看选课名单）只需在对应角色菜单中增加分支和处理函数，无需重构整体交互逻辑。
2. **默认数据初始化**：`initDefaultUsers`函数初始化基础学生/教师/秘书/课程数据，既方便测试，也为后续“用户注册”功能提供了兼容基础。

## 六、开发中的问题与优化思考
### 1. 已发现的潜在问题
- 数据持久化不完整：当前`saveData`仅保存学生/课程的基础信息（ID、名称、学分），未序列化“学生选课关系”“成绩信息”，重启系统后关联数据丢失，需基于`nlohmann/json`完善实体关联数据的序列化。
- 循环引用风险：`Teacher`与`Course`互相持有`shared_ptr`，可能导致对象引用计数无法归零，后续需将一方改为`weak_ptr`（如`Course`中存储`weak_ptr<Teacher>`）。

### 2. 优化方向
- 交互体验升级：当前命令行交互仅支持单条操作，可增加“批量录成绩”“批量选课”功能，减少重复操作；
- 线程安全：当前为单线程设计，若扩展为多用户场景，需为`DataManager`的接口增加互斥锁，避免并发修改数据；
- 日志体系：新增日志模块，记录关键操作（如选课、录成绩）和异常信息，方便问题排查。

## 七、核心总结
Registrar模块的开发核心是“把复杂的业务逻辑拆简单，把简单的逻辑做扎实”：
- 模块化和接口抽象是“拆简单”的关键，让核心业务与实体定义、数据实现解耦，避免逻辑纠缠；
- 分层校验和异常处理是“做扎实”的基础，让系统在用户误操作、数据异常时仍能稳定运行；
- 面向接口和预留扩展点，让模块不仅满足当前需求，也能适配未来的迭代。

整个开发过程也验证了：好的业务模块不是“功能堆砌”，而是“职责清晰、边界明确、防护到位、扩展可控”——这也是后续开发复杂C++业务模块的核心准则。
